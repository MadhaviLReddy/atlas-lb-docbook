<?xml version="1.0" encoding="UTF-8"?>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
    <title>Load Balancing Service API Specification</title>
    <info>
        <author>
            <personname>
                <firstname/>
                <surname/>
            </personname>
            <affiliation>
                <orgname>Rackspace Cloud</orgname>
            </affiliation>
        </author>
        <copyright>
            <year>2010</year>
            <holder>Rackspace Hosting, Inc.</holder>
        </copyright>

        <releaseinfo/>

        <productname>Cloud Sites: LBaaS</productname>
        <pubdate>11/11/10</pubdate>
        <abstract>
            <para/>
        </abstract>
    </info>
    <chapter>
        <title>Intended Audience</title>
        <para>
            This guide is intended for software developers who want to develop applications using the Load balancing Service API. It assumes the reader has a general understanding of the Load Balancing service and is familiar with:
        </para>
        <para>
            <itemizedlist>
                <listitem>
                    <para>RESTful Web Services</para>
                </listitem>
                <listitem>
                    <para>HTTP/1.1 Conventions</para>
                </listitem>
                <listitem>
                    <para>JSON and/or Serialization Formats</para>
                </listitem>
                <listitem>
                    <para>Atom Syndication Format</para>
                </listitem>
            </itemizedlist>
        </para>
    </chapter>
    <chapter id="concepts-and-definitions">
        <title>Concepts and Definitions</title>
        <para>
            The load balancing API specification has several key concepts that are important to understand.
        </para>
        <sect3 id="load-balancer">
            <title>Load balancer</title>
            <para>
                A load balancer is a logical device, which belongs to a cloud account. It is used to distribute workloads between multiple back-end systems or services, based on the criteria defined as part of the configuration.
            </para>
        </sect3>
        <sect3 id="virtual-ip">
            <title>Virtual IP</title>
            <para>
                A virtual IP is an address configured on the load balancer for use by clients connecting to a service that is load balanced. Incoming connections are distributed to back-end nodes based on the configuration of the load balancer.
            </para>
        </sect3>
        <sect3 id="node">
            <title>Node</title>
            <para>
                A nodes is a back-end device providing a service on a given IP and port.
            </para>
        </sect3>
        <sect3 id="health-monitor">
            <title>Health Monitor</title>
            <para>
                A health monitor is a feature of the load balancer that is used to determine whether or not a backend node is usable for processing a request.  The service supports two types of health monitors, passive and active.
            </para>
        </sect3>
        <sect3 id="passive-health-monitor">
            <title>Passive Health Monitor</title>
            <para>
                By default, all load balancing configurations utilize a passive health monitor, which is a technique that analyzes the response of the backend server to determine whether or not its capable of processing a request.  Passive health monitoring verifies the condition of a node using the following criteria:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>The connection is refused by the backend server or if the connection takes longer than 4 seconds to be established.</para>
                    </listitem>
                    <listitem>
                        <para>The connection is closed prematurely or if the beginning of the response is not received within 30 seconds.</para>
                    </listitem>
                    <listitem>
                        <para>HTTP - If an invalid HTTP response is received or a 503 (Service Unavailable) response code is received.</para>
                    </listitem>
                    <listitem>
                        <para>SSL Passthrough - If the SSL handshake to the backend server fails.</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                If the tests above fail, then the service will attempt to locate another configured node that is capable of supporting the request until every node is exhausted.  If this occurs, the requestor will receive a 503/Service Unavailable for HTTP traffic or the connection will be dropped.
            </para>
            <note>
                If a given node fails a passive health monitor check for three consecutive times, then the service assumes the node has failed and will place it in the OFFLINE status.  The service will not attempt to send any new requests to the node for at least 60 seconds after which the service will speculatively begin sending requests to occasionally probe it to determine whether or not it has recovered.
            </note>
        </sect3>
        <sect3 id="active-health-monitor">
            <title>Active Health Monitor</title>
            <para>
                Active health monitoring is a technique that uses synthetic transactions that are executed at periodic intervals to determine the condition of a node.  One of the advantages of active health monitoring is that it does not require active transactions to be processed by the load balancer to determine whether or not a node is suitable for handling traffic.  When both active and passive monitoring are enabled, the decisions made by the active monitor override inferences made by the passive monitoring system.
            </para>
            <para>
                The active health monitor can use one of three types of probes: connect, http, and https.  These probes are run at configured intervals and in the event of a failure, the node status changes to OFFLINE and the node will not receive traffic.  Once the probe has detected that the node has recovered (by running a subsequent test), then the node is changed to the ONLINE status and will be capable of servicing requests.
            </para>
        </sect3>
        <sect3 id="session-persistence">
            <title>Session Persistence</title>
            <para>
                Session persistence is a feature of the load balancing service that attempts to force subsequent connections to a service to be redirected to the same node as long as its online.
            </para>
        </sect3>
        <sect3 id="connection-logging">
            <title>Connection Logging</title>
            <para>
                The connection logging feature allows for Apache-style access logs (for HTTP-based protocol traffic) or connection and transfer logging (for all other traffic) to your Cloud Files account. Logs are delivered to your account every hour.
            </para>
        </sect3>
    </chapter>
    <chapter id="general-api-information">
        <title>General API Information</title>
        <para>
            The Load Balancing Service API is implemented using a RESTful web service interface. Like other products in the Rackspace Cloud suite. The Load Balancing Service shares a common token-based authentication system that allows seamless access between products and services.
        </para>
            <note>All requests to authenticate and operate the service are performed using SSL over HTTP (HTTPS) on TCP port 443.</note>
        <sect1 id="authentication">
            <title>Authentication</title>
            <para>
                Every REST request against the load balancing service requires the inclusion of a specific authorization token, which is supplied by the X-Auth-Token HTTP header. Customers obtain this token by first using the Rackspace Cloud Authentication Service and supplying a valid username and API access key.
            </para>
            <sect2 id="auth-request">
                <title>Request</title>
                <para>The Rackspace Cloud Authentication Service serves as the entry point to all Rackspace Cloud APIs and is itself a RESTful web service. It is accessible at
                    <link xlink:href="https://auth.api.rackspacecloud.com/v1.0">https://auth.api.rackspacecloud.com/v1.0</link>. In order to authenticate, you must supply your username and API access key in the X-Auth-Key HTTP headers. Username is your common Rackspace Cloud username and your API access key can be obtained from the Rackspace Cloud Control Panel in the Your Account | API Access section.
                </para>
            </sect2>
            <sect2 id="auth-request-sample">
                <title>Sample Request</title>
                <para>
                    <literallayout class="monospaced">
GET /v1.0 HTTP/1.1
Host: auth.api.rackspacecloud.com
X-Auth-User: jdoe
X-Auth-Key: a86850deb2742ec3cb41518e26aa2d89
                    </literallayout>
                </para>
            </sect2>
            <sect2 id="auth-response">
                <title>Response</title>
                <para>If authentication is successful, an HTTP status 204 No Content is returned with an X-Auth-Token (along with other Cloud Service headers that are not applicable to the load balancing service). An HTTP status of 401 Unauthorized is returned if authentication fails. All operations against the load balancing service must include the X-Auth-Token header as noted above.
                </para>
            </sect2>
            <sect2>
                <title>Sample Response</title>
                <para>
                    <literallayout class="monospaced">
HTTP/1.1 204 No Content
Date: Mon, 12 Nov 2007 15:32:21 GMT
Server: Apache
X-Server-Management-Url: https://servers.api.rackspacecloud.com/v1.0/35428
X-Storage-Url: https://storage.clouddrive.com/v1/CloudFS_9c83b-5ed4
X-CDN-Management-Url: https://cdn.clouddrive.com/v1/CloudFS_9c83b-5ed4
X-Auth-Token: eaaafd18-0fed-4b3a-81b4-663c99ec1cbb
Content-Length: 0
Content-Type: text/plain; charset=UTF-8
                    </literallayout>
                </para>
            </sect2>
            <para>
                Authentication tokens are typically valid for 24 hours. Applications should be designed to re-authenticate after receiving a 401 Unauthorized response from a service endpoint.
            </para>
            <note>
                LBaaS will depend on Cloud Auth 1.1, which will include the endpoints in the response payload - To be updated once contract is solidified with auth developers.
            </note>
        </sect1>
        <sect1 id="service-access">
            <title>Service Access</title>
            <para>
                The load balancing service is a regionalized service, which allows for the caller to select a region to provision a load balancer into. In the response payload provided by the authentication service, the caller can choose the appropriate region-based endpoint.
            </para>
            <para>
                <emphasis>If load balancing Cloud Servers</emphasis>, you can determine the appropriate region to select by viewing your Cloud Servers list and creating a load balancer within the same region as the data center in which your Cloud Server resides in. When your resources reside in the same region as your load balancer, it ensures your devices are in close proximity to each other and allows you to take advantage of ServiceNet connectivity for free data transfer between services.
            </para>
            <para>
                <emphasis>If load balancing external servers</emphasis>, you can determine the appropriate region to select by choosing the region that is geographically as close to your external servers as possible.
            </para>
        </sect1>
        <sect1 id="request-response-types">
            <title>Request/Response Types</title>
            <para>The load balancing API supports both the JSON and XML data serialization formats. The request format is specified using the
                <emphasis>Content-Type</emphasis>
                header and is required for operations that have a request body. The response format can be specified in requests using either the
                <emphasis>Accept</emphasis>
                header or adding an
                <emphasis>.xml</emphasis>
                or
                <emphasis>.json</emphasis>
                extension to the request URI. Note that it is possible for a response to be serialized using a format different from the request (see example below). If no response format is specified, JSON is the default. If conflicting formats are specified using both an Accept header and a query extension, the query extension takes precedence.
            </para>
            <para>
                Some operations support an Atom representation that can be used to efficiently determine when the state of services has changed.
            </para>
            <table border="box">
                <thead>
                    <tr>
                        <td>Format</td>
                        <td>Accept Header</td>
                        <td>Query Extension</td>
                        <td>Default</td>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Json</td>
                        <td>application/json</td>
                        <td>.json</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td>XML</td>
                        <td>application/xml</td>
                        <td>.xml</td>
                        <td>No</td>
                    </tr>
                    <tr>
                        <td>Atom</td>
                        <td>application/atom+xml</td>
                        <td>.atom</td>
                        <td>No</td>
                    </tr>
                </tbody>
            </table>
        </sect1>
        <sect1 id="content-compression">
            <title>Content Compression</title>
            <para>
                Request and response body data may be encoded with gzip compression in order to accelerate interactive performance of API calls and responses. This is controlled using the Accept-Encoding header on the request from the client and indicated by the Content-Encoding header in the server response. Unless the header is explicitly set, encoding defaults to disabled.
            </para>
            <table border="box">
                <thead>
                    <tr>
                        <td>Header Type</td>
                        <td>Name</td>
                        <td>Value</td>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>HTTP/1.1 Request</td>
                        <td>Accept-Encoding</td>
                        <td>gzip</td>
                    </tr>
                    <tr>
                        <td>HTTP/1.1 Response</td>
                        <td>Content-Encoding</td>
                        <td>gzip</td>
                    </tr>
                </tbody>
            </table>
        </sect1>
        <sect1 id="persistence-connections">
            <title>Persistence Connections</title>
            <para>
                By default, the API supports persistent connections via HTTP/1.1 keepalives. All connections will be kept alive unless the connection header is set to close.
            </para>
            <para>
                To prevent abuse, HTTP sessions have a timeout of 20 seconds before being closed.
            </para>
            <note>
                The server may close the connection at any time and clients should not rely on this behavior.
            </note>
        </sect1>
        <sect1 id="paginated-collections">
            <title>Paginated Collections</title>
            <para>
                To reduce load on the service, list operations will return a maximum of 100 items at a time. To navigate the collection, the parameters limit and offset can be set in the URI (e.g.?limit=0&amp;offset=0). If an offset is given beyond the end of a list an empty list will be returned. Note that list operations never return itemNotFound (404) faults.
            </para>
        </sect1>
        <sect1 id="efficient-polling-changes-since-parameter">
            <title>Efficient Polling with the Changes-Since Parameter</title>
            <para>The REST API allows you to poll for the status of certain operations by performing a GET on various URIs. Rather than re-downloading and re-parsing the full status at each polling interval, your REST client may use the changes-since parameter to check for changes since a previous request. The changes-since time is specified as Unix time (the number of seconds since January 1, 1970, 00:00:00 UTC, not counting leap seconds). If nothing has changed since the changes-since time, a 304 Not Modified response will be returned. If data has changed, only the items changed since the specified time will be returned in the response. For example, performing a GET against https://URL/v1.0/1234/loadbalancers?changes-since=1244012982 would list all load balancers that have changed since Wed, 03 Jun 2009 07:09:42 UTC.
            </para>
        </sect1>
    </chapter>
    <chapter>
        <title>API Operations</title>
        <sect1 id="load-balancers">
            <sect2 id="list-load-balancers">
                <title>List Load Balancers</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                            <td>Representation</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers</td>
                            <td>List all load balancers configured for the account (IDs, names and status only)</td>
                            <td>XML, JSON</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault (400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        This operation provides a list of all load balancers configured and associated with your account.
                    </para>
                    <para>
                        <emphasis>Deleted Load Balancers</emphasis>
                    </para>
                    <para>
                        Load balancer which have been deleted will be shown in this list until all usage has been processed and invoiced. A deleted load balancer is immutable and irrecoverable. Only a limited set of attributes will be returned in the response object (id, name, status, created, and updated).
                    </para>
                </sect3>
                <sect3>
                    <title>Request</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Sample XML Response (/loadbalancers)</title>
                    <literallayout class="monospaced">
<![CDATA[<?xml version="1.0" ?>
<loadBalancers xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
	<loadBalancer id="71" name="lb-site1" status="ACTIVE"
		protocol="HTTP" port="80" algorithm="RANDOM">
		<virtualIps>
			<virtualIp id="403" address="206.55.130.1" ipVersion="IPV4"
				type="PUBLIC" />
		</virtualIps>
		<created time="2010-12-13T15:38:27-06:00" />
		<updated time="2010-12-13T15:38:38-06:00" />
	</loadBalancer>
	<loadBalancer id="166" name="lb-site2" status="ACTIVE"
		protocol="HTTP" port="80" algorithm="RANDOM">
		<virtualIps>
			<virtualIp id="401" address="206.55.130.2" ipVersion="IPV4"
				type="PUBLIC" />
		</virtualIps>
		<created time="2010-12-13T15:38:27-06:00" />
		<updated time="2010-12-13T15:38:38-06:00" />
	</loadBalancer>
</loadBalancers>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample Json Response (/loadbalancers)</title>
                    <literallayout class="monospaced">
<![CDATA[{"loadBalancers":[
      {
         "name":"lb-site1",
         "id":"71",
         "protocol":"HTTP",
         "port":"80",
         "algorithm":"RANDOM",
         "status":"ACTIVE",
         "virtualIps":[
            {
               "id":"403",
               "address":"206.55.130.1",
               "type":"PUBLIC",
               "ipVersion":"IPV4"
            }
         ],
         "created":{
            "time":"2010-11-30T03:23:42.000+0000"
         },
         "updated":{
            "time":"2010-11-30T03:23:44.000+0000"
         }
      },
      {
         "name":"lb-site2",
         "id":"166",
         "protocol":"HTTP",
         "port":"80",
         "algorithm":"RANDOM",
         "status":"ACTIVE",
         "virtualIps":[
            {
               "id":"401",
               "address":"206.55.130.2",
               "type":"PUBLIC",
               "ipVersion":"IPV4"
            }
         ],
         "created":{
            "time":"2010-11-30T03:23:42.000+0000"
         },
         "updated":{
            "time":"2010-11-30T03:23:44.000+0000"
         }
      }
   ]
}]]>
                    </literallayout>
                </sect3>
            </sect2>
            <sect2 id="list-load-balancer-details">
                <title>List Load Balancer Details</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                            <td>Representations</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId</td>
                            <td>List details of the specified load balancer</td>
                            <td>JSON, XML, ATOM</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        This operation provides the detailed output for a specific load balancer configured and associated with your account.  This operation is not capable of returning details for a load balancer which has been deleted.
                    </para>
                </sect3>
                <sect3>
                    <title>Request</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Sample XML Response</title>
                    <literallayout class="monospaced">
<![CDATA[<loadBalancer xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
   id="2000"
   name="sample-loadbalancer"
   protocol="HTTP"
   port="80"
   algorithm="RANDOM"
   status="ACTIVE">
   <connectionLogging enabled="false" />
  <virtualIps>
      <virtualIp
         id="1000"
         address="206.10.10.210"
         type="PUBLIC"
         ipVersion="IPV4" />
   </virtualIps>
   <nodes>
      <node
         nodeId="1041"
         address="10.1.1.1"
         port="80"
         condition="ENABLED"
         status="ONLINE" />
      <node
         nodeId="1411"
         address="10.1.1.2"
         port="80"
         condition="ENABLED"
         status="ONLINE" />
   </nodes>
   <sessionPersistence persistenceType="HTTP_COOKIE"/>
   <connectionThrottle
      minConnections="10"
      maxConnections="100"
      maxConnectionRate="50"
      rateInterval="60" />
   <cluster name="c1.dfw1" />
   <created time="2010-11-30T03:23:42Z" />
   <updated time="2010-11-30T03:23:44Z" />
</loadBalancer>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response</title>
                    <literallayout>
<![CDATA[{
   "loadBalancer":{
      "id":"2000",
      "name":"sample-loadbalancer",
      "protocol":"HTTP",
      "port":"80",
      "algorithm":"RANDOM",
      "status":"ACTIVE",
      "connectionLogging":{
         "enabled":"true"
      },
      "virtualIps":[
         {
            "id":"1000",
            "address":"206.10.10.210",
            "type":"PUBLIC",
            "ipVersion":"IPV4"
         }
      ],
      "nodes":[
         {
            "id":"1041",
            "address":"10.1.1.1",
            "port":"80",
            "condition":"ENABLED",
            "status":"ONLINE"
         },
         {
            "id":"1411",
            "address":"10.1.1.2",
            "port":"80",
            "condition":"ENABLED",
            "status":"ONLINE"
         }
      ],
      "sessionPersistence":{
         "persistenceType":"HTTP_COOKIE"
      },
      "connectionThrottle":{
         "minConnections":"10",
         "maxConnections":"100",
         "maxConnectionRate":"50",
         "rateInterval":"60"
      },
      "cluster":{
         "name":"c1.dfw1"
      },
      "created":{
         "time":"2010-11-30T03:23:42.000+0000"
      },
      "updated":{
         "time":"2010-11-30T03:23:44.000+0000"
      }
   }
}]]>
                    </literallayout>
                </sect3>
            </sect2>
            <sect2>
                <title>Create Load Balancer</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>POST</td>
                            <td>/loadbalancers</td>
                            <td>Create a new load balancer with the configuration defined by the request.</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Reponse Code(s):</emphasis> 202
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        This operation asynchronously provisions a new load balancer based on the configuration defined in the request object. Once the request is validated and progress has started on the provisioning process, a response object will be returned. The object will contain a unique identifier and status of the request. Using the identifier, the caller can check on the progress of the operation by performing a GET on loadbalancers/id (for more details on this operation see the "List Load Balancer Details" section of this document). If the corresponding request cannot be fulfilled due to insufficient or invalid data, an HTTP 400 "Bad Request" error response will be returned with information regarding the nature of the failure in the body of the response. Failures in the validation process are non-recoverable and require the caller to correct the cause of the failure and POST the request again.
                    </para>
                    <note>
                        A load balancer's name must be less than or equal to 128 characters.
                    </note>
                    <note>
                        Users may configure all documented features of the load balancer at creation time by simply providing the additional elements / attributes in the request. Refer to the subsequent sections of this specification for an overview of all features the load balancing service supports.
                    </note>
                </sect3>
                <sect3 id="sharing-virtual-ips-between-load-balancers">
                    Sharing Virutal IPs Between Load Balancers
                    <para>
                        In order to conserve IPv4 address space, Rackspace highly recommends sharing Virtual IPs between your load balancers. If you have at least one load balancer, you may create subsequent load balancers that share a single virtual IP by issuing a POST and supplying a virtualIp ID instead of a type. (see below for a sample request). Additionally, this feature is highly desirable if you wish to load balance both an unsecured and secure protocol using one IP / DNS name (for example, HTTP and HTTPS).
                    </para>
                    <note>
                        Load balancers sharing a virtual IP <emphasis>must</emphasis> utilize a unique port.
                    </note>
                </sect3>
                <sect3>
                    <title>Sample XML Request (Required Attributes Only)</title>
                    <literallayout class="monospaced">
<![CDATA[<loadBalancer xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
              name="a-new-loadbalancer"
              port="80"
              protocol="HTTP">
    <virtualIps>
        <virtualIp type="PUBLIC"/>
    </virtualIps>
    <nodes>
        <node address="10.1.1.1" port="80" condition="ENABLED"/>
    </nodes>
</loadBalancer>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Request (Required Attributes Only)</title>
                    <literallayout class="monospaced">
<![CDATA[{"loadBalancer": {
        "name": "a-new-loadbalancer",
        "port": "80",
        "protocol": "HTTP",
        "virtualIps": {
            "virtualIp": {
                "type": "PUBLIC"
            }
        },
        "nodes": {
            "node": {
                "address": "10.1.1.1",
                "port": "80",
                "condition": "ENABLED"
            }
        }
    }
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Request (Required Attributes Only w/ Shared IP)</title>
                    <literallayout class="monospaced">
<![CDATA[<loadBalancer xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
   name="a-new-loadbalancer"
   port="80"
   protocol="HTTP">
   <virtualIps>
      <virtualIp id="2341"/>
   </virtualIps>
   <nodes>
      <node address="10.1.1.1" port="80" condition="ENABLED" />
   </nodes>
</loadBalancer>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Request (Required Attributes Only w/ Shared IP)</title>
                    <literallayout>
<![CDATA[{
   "loadBalancer":{
      "name":"a-new-loadbalancer",
      "port":"80",
      "protocol":"HTTP",
      "virtualIps":[
         {
            "id":"2341"
         }
      ],
      "nodes":[
         {
            "address":"10.1.1.1",
            "port":"80",
            "condition":"ENABLED"
         }
      ]
   }
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Response</title>
                    <literallayout class="monospaced">
<![CDATA[<loadBalancer xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
   id="1041"
   name="a-new-loadbalancer"
   status="BUILD"
   port="80"
   protocol="HTTP">
   <virtualIps>
      <virtualIp
         id="1000"
         address="206.10.10.210"
         type="PUBLIC" />
   </virtualIps>
   <nodes>
      <node address="10.1.1.1" port="80" condition="ENABLED" />
   </nodes>
</loadBalancer>]]>
                    </literallayout>
                </sect3>
            </sect2>
            <sect2>
                <title>Remove Load Balancer</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId</td>
                            <td>Removes a load balancer from your account</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 202
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable(503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        The remove load balancer function removes the specified load balancer and its associated configuration from the account. Any and all configuration data is immediately purged and is not recoverable.
                    </para>
                </sect3>
                <sect3>
                    <title>Request</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
            </sect2>
            <sect2>
                <title>List, Add, Modify, and Remove Nodes</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/nodes</td>
                            <td>List node(s) configured for the load balancer</td>
                        </tr>
                        <tr>
                            <td>POST</td>
                            <td>/loadbalancers/loadBalancerId/nodes</td>
                            <td>Add a new node to the load balancer</td>
                        </tr>
                        <tr>
                            <td>PUT</td>
                            <td>/loadbalancers/loadBalancerId/nodes/nodeId</td>
                            <td>Modifies the configuration of a node on the load balancer</td>
                        </tr>
                        <tr>
                            <td>DELTE</td>
                            <td>/loadbalancers/loadBalancerId/nodes/nodeId</td>
                            <td>Removes a node from the load balancer</td>
                        </tr>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/nodes/nodeId</td>
                            <td>List details for a specific node</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 20, 202
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        The nodes defined by the load balancer are responsible for servicing the requests received through the load balancers virtual IP. By default, the load balancer employs a basic "health check" that ensures the node is listening on its defined port. The node is checked at the time of addition and at regular intervals as defined by the load balancer health check configuration (for more information on health check settings, see the "Health Check" section of this document) If a back-end node is not listening on its port or does not meet the conditions of the defined health check for the load balancer, then the load balancer will not forward connections and its status will be listed as <emphasis>"OFFLINE"</emphasis>. Only nodes that are in an <emphasis>"ONLINE"</emphasis> stats will receive and be able to service traffic from the load balancer.
                    </para>
                    <para>
                        All nodes have an associated status that indicates if the node is online, offline or draining. Only nodes that are in an "<emphasis>ONLINE</emphasis>" status will receive and be able to service traffic from the load balancer. The "<emphasis>OFFLINE</emphasis>" status represents a node that cannot accept or service traffic. A node in "<emphasis>DRAINING</emphasis>" status represents a node that stops the traffic manager from sending any more new connections to the node, but honors established sessions. If the traffic manager receives a request and session persistence requires that the node is used, the traffic manager will use it. The status is determined either by the passive or active health monitors.  For more information on health monitoring, see the concepts and definitions section (above).
                    </para>
                    <para>
                        If the weighted round robin load balancer algorithm mode is selected (WEIGHTED_ROUND_ROBIN), then the caller should assign the relevant weights to the node as part of the weight attribute of the node element. When the algorithm of the load balancer is changed to weighted round robin and the nodes do not already have an assigned weight, the service will automatically set the weight to "1" for all nodes.
                    </para>
                    <para>
                        When a node is added, it is assigned a unique identifier that can be used for mutating operations such as changing the port and condition, or removing it. Every load balancer is dual homed on both the public Internet and ServiceNet and as a result, nodes can either be internal ServiceNet addresses or addresses on the public Internet.
                    </para>
                </sect3>
                <sect3>
                    <title>Request (GET)</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Sample XML Response (Get)</title>
                    <literallayout class="monospaced">
<![CDATA[<node
        id="410"
        address="10.1.1.1"
        port="80"
        condition="ENABLED"
        status="ONLINE"/>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Request (POST)(Required attributes only)</title>
                    <literallayout class="monospaced">
<![CDATA[<nodes xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <node
            address="10.1.1.1"
            port="80"
            condition="ENABLED"/>
</nodes>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Response (POST)</title>
                    <literallayout class="monospaced">
<![CDATA[<nodes xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <node
            address="10.1.1.1"
            port="80"
            condition="ENABLED"
            status="ONLINE" />
</nodes>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Request (POST)(Required attributes) (/loadbalancers/loadBalancerId/nodes)</title>
                    <literallayout class="monospaced">
<![CDATA[{"nodes": [
        {
            "port": 80,
            "condition": "ENABLED",
            "address": "10.1.1.1"
        }
    ]
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response (POST)</title>
                    <literallayout class="monospaced">
<![CDATA[{"nodes": [
        {
            "address": "10.1.1.1",
            "port": "80",
            "condition": "ENABLED"
            "status": "PENDING_UPDATE"
        }
    ]
}]]>
                    </literallayout>
                </sect3>
                <note>
                    The node's IP and Port are immutable attributes and cannot be modified by the caller for a PUT request. Supplying an unsupported attribute will result in a badRequest (400) fault.
                </note>
                <sect3>
                    <title>Sample XML Request (PUT) (/loadbalancers/loadBalancerId/nodes/nodeId) Mutable Attributes Only</title>
                    <literallayout class="monospaced">
<![CDATA[<node xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
      condition="DISABLED"/>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Request (PUT) (/loadbalancers/loadBalancerId/nodes/nodeId)</title>
                    <literallayout class="monospaced">
<![CDATA[{
   "node":{
      "condition":"DISABLED"
   }
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Response (PUT)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
                <sect3>
                    <title>Request (DELETE)</title>
                    <para>
                        This operation does not require a method body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response (DELETE)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
            </sect2>
            <sect2>
                <title>Update Name, Algorithm, Protocol, and/or Port Attributes of a Load Balancer</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>PUT</td>
                            <td>/loadbalancers/loadBalancerId</td>
                            <td>Update the properites of a load balancer</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 202
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        This operation asynchronously updates the attributes of a given load balancer. Upon successful validation of the request, the service will return a 202/Accepted response code. A caller can subscribe to event notifications through the notification service <emphasis>or</emphasis> poll the load balancer with its ID to wait for the changes to be applied and the load balancer to return to an <emphasis>ACTIVE</emphasis> status. This operation allows the caller to change one or more of the following attributes:
                    </para>
                    <itemizedlist mark='opencircle'>
                        <listitem>
                            <para>name</para>
                        </listitem>
                        <listitem>
                            <para>algorithm</para>
                        </listitem>
                        <listitem>
                            <para>protocol</para>
                        </listitem>
                        <listitem>
                            <para>port</para>
                        </listitem>
                    </itemizedlist>
                    <note>
                        The load balancer's ID and status are immutable attributes and cannot be modified by the caller. Supplying an unsupported attribute will result in a badRequest (400) fault.
                    </note>
                </sect3>
                <sect3>
                    <title>Sample XML (PUT)(Mutable Attributes Only)</title>
                    <literallayout class="monospaced">
<![CDATA[<loadBalancer xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
        name="sample-loadbalancer"
        algorithm="RANDOM"
        protocol="HTTP"
        port="80" />]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON (PUT)(Mutable Attributes Only)</title>
                    <literallayout class="monospaced">
<![CDATA[{
    "name": "sample-loadbalancer",
    "algorithm": "RANDOM",
    "protocol": "HTTP",
    "port": "80",
    "connectionLogging": "true"
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Response</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
            </sect2>
            <sect2>
                <title>Virtual IP Management</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/virtualips</td>
                            <td>List all associated virtual IPs</td>
                        </tr>
                        <tr>
                            <td>DELETE</td>
                            <td>/loadbalancers/loadBalancerId/virtualIpId</td>
                            <td>Remove the Virtual IP</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200, 202
                </para>
                <para>
                    <emphasis>Error REsponse Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        A virtual IP (VIP) is how your load balancer is reached by clients. The load balancing service, supports either a public VIP, which is routable on the public Internet or a ServiceNet address, which is routable only within the region your load balancer resides in.
                    </para>
                    <note>
                        All load balancers must have at least one Virtual IP associated to them at all times. Attempting to delete the last virtual IP will result in a badRequest (400) fault.
                    </note>
                </sect3>
                <sect3>
                    <title>Virtual IP Types</title>
                    <table border="box">
                        <thead>
                            <tr>
                                <td>Name</td>
                                <td>Description</td>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>PUBLIC</td>
                                <td>An address that is routable on the public Internet</td>
                            </tr>
                            <tr>
                                <td>SERVICENET</td>
                                <td>An address that is routable only on ServiceNet</td>
                            </tr>
                        </tbody>
                    </table>
                </sect3>
                <sect3>
                    <title>Request (GET)</title>
                    <para>
                        This request does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Sample XML GET Response (/loadbalancers/loadBalancerId/virtualips)</title>
                    <literallayout class="monospaced">
<![CDATA[<virtualIps xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <virtualIp
            id="1000"
            address="206.10.10.210"
            type="PUBLIC"/>
</virtualIps>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON XML Response (/loadbalancers/loadBalancerId/virtualips)</title>
                    <literallayout class="monospaced">
<![CDATA[{"virtualIps": [
        {
            "id": "1000",
            "address": "206.10.10.210",
            "type": "PUBLIC"
        }
    ]
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Request (DELETE)</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response (DELETE)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
            </sect2>
            <sect2>
                <title>Usage Reporting</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Name</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/usage</td>
                            <td>List current and historical usage</td>
                        </tr>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/usage/current</td>
                            <td>List current usage</td>
                        </tr>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/historical</td>
                            <td>List historical usage</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        The service usage provides current and a historical view of tier profiles and transfer associated with the load balancing service. Current usage represents any usage that been incurred since the endDate of the most recent historical usage object. Current usage is processed into historical usage objects every 24 hours or whenever an event occurs that changes a billing-related attribute (for example, changing the tier profiles of a load balancer). Values for both incomingTransfer and outgoingTransfer are expressed in bytes transferred.
                    </para>
                    <note>
                        Historical usage is available for up to 90 days of service activity.
                    </note>
                </sect3>
                <sect3>
                    <title>Request</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Sample XML Response (GET - for all usage)</title>
                    <literallayout class="monospaced">
<![CDATA[<loadBalancerUsage xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
  <loadBalancerUsageRecord
        id="394"
        averageNumConnections="0.0"
        incomingTransfer="0"
        outgoingTransfer="0"
        numVips="1"
        numPolls="32"
        startTime="2010-12-21T12:32:07-06:00"
        endTime="2010-12-21T16:23:54-06:00" />
  <loadBalancerUsageRecord
        id="473"
        averageNumConnections="0.0"
        incomingTransfer="0"
        outgoingTransfer="0"
        numVips="2"
        numPolls="5"
        startTime="2010-12-21T12:32:07-06:00"
        endTime="2010-12-21T12:36:30-06:00" />
</loadBalancerUsage>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response (GET)</title>
                    <literallayout class="monospaced">
<![CDATA[{
    "loadBalancerUsageRecords": [
        {
            "id": "394",
            "averageNumConnections": "0.0",
            "incomingTransfer": "0",
            "outgoingTransfer": "0",
            "numVips": "1",
            "numPolls" "32",
            "startTime": "2010-12-21T12:32:07-06:00",
            "endTime": "2010-12-21T16:23:54-06:00"
        },
        {
            "id": "473",
            "averageNumConnections": "0.0",
            "incomingTransfer": "0",
            "outgoingTransfer": "0",
            "numVips": "2",
            "numPolls": "5",
            "startTime": "2010-12-21T12:32:07-06:00",
            "endTime": "2010-12-21T12:36:30-06:00"
        }
    ]
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Response (/loadbalancers/usage?startDate=2010-11-30&amp;endDate=2010-12-01)</title>
                    <literallayout>
<![CDATA[<accountBilling xmlns="http://docs.openstack.org/loadbalancers/api/v1.0" accountId="1106">
  <accountUsage>
    <accountUsageRecord numLoadBalancers="2" numPublicVips="1" numServicenetVips="0" startTime="2010-12-01T14:09:14-06:00"/>
  </accountUsage>
  <loadBalancerUsage loadBalancerId="66" loadBalancerName="My first loadbalancer">
    <loadBalancerUsageRecord id="394" averageNumConnections="0.0" incomingTransfer="0" outgoingTransfer="0" numVips="1"
        numPolls="32" startTime="2010-12-21T12:32:07-06:00" endTime="2010-12-21T16:23:54-06:00"/>
    <loadBalancerUsageRecord id="473" averageNumConnections="0.0" incomingTransfer="0" outgoingTransfer="0" numVips="2"
        numPolls="5" startTime="2010-12-21T12:32:07-06:00" endTime="2010-12-21T12:36:30-06:00"/>
    <loadBalancerUsageRecord id="474" averageNumConnections="0.0" incomingTransfer="0" outgoingTransfer="0" numVips="2"
        numPolls="5" startTime="2010-12-21T12:32:07-06:00" endTime="2010-12-21T12:36:30-06:00"/>
    <loadBalancerUsageRecord id="475" averageNumConnections="0.0" incomingTransfer="0" outgoingTransfer="0" numVips="2"
        numPolls="5" startTime="2010-12-21T12:32:07-06:00" endTime="2010-12-21T12:36:30-06:00"/>
</loadBalancerUsage>
  <loadBalancerUsage loadBalancerId="77" loadBalancerName="My second loadbalancer">
    <loadBalancerUsageRecord id="394" averageNumConnections="0.0" incomingTransfer="0" outgoingTransfer="0" numVips="1"
       numPolls="32" startTime="2010-12-21T12:32:07-06:00" endTime="2010-12-21T16:23:54-06:00"/>
   <loadBalancerUsageRecord id="473" averageNumConnections="0.0" incomingTransfer="0" outgoingTransfer="0" numVips="2" numPolls="5"
       startTime="2010-12-21T12:32:07-06:00" endTime="2010-12-21T12:36:30-06:00"/>
 <loadBalancerUsage/>
</accountBilling>]]>
                    </literallayout>
                </sect3>
            </sect2>
            <sect2>
                <title>Access List Management</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Name</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/accesslist</td>
                            <td>List the access list</td>
                        </tr>
                        <tr>
                            <td>POST</td>
                            <td>/loadbalancers/loadBalancerId/accesslist</td>
                            <td>Create a new access list or replace an existing access list</td>
                        </tr>
                        <tr>
                            <td>PUT</td>
                            <td>/loadbalancers/loadBalancerId/accesslist</td>
                            <td>Append additional network items to the access list</td>
                        </tr>
                        <tr>
                            <td>DELETE</td>
                            <td>/loadbalancers/loadBalancerId/accesslist/networkItemId</td>
                            <td>Remove a network item from the access list</td>
                        </tr>
                        <tr>
                            <td>DELETE</td>
                            <td>/loadbalancers/loadBalancerId/accesslist</td>
                            <td>Remove the netire access list</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200, 202
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        The access list management feature allows for fine-grained network access controls to be applied to the load balancer's virtual IP address. A single IP address, multiple IP addresses, or entire network subnets can be added as a networkItem. Items that are configured with the <emphasis>DENY</emphasis> type will always take precedence over items with the <emphasis>ALLOW</emphasis> type. To reject traffic from all items, except for those with the <emphasis>ALLOW</emphasis> type, a networkItem with an address of "0.0.0.0/0" should be added with a <emphasis>DENY</emphasis> type.
                    </para>
                    <para>
                        When issuing a POST to add to an access list, one or more network items are required. If a populated access list already exists for the load balancer, it will be replaced with subsequent POST requests.  To append to the access list, a PUT request should be issued. Like the POST operation the PUT operation requires one or more network items. A single address or subnet definition is considered unique and cannot be duplicated between items in an access list. There are two DELETE operations for the access list. One allows for deletion of the entire access list and the other for deletion of a specific network item in the access list.
                    </para>
                </sect3>
                <sect3>
                    <title>Request (GET)</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Sample XML Response (GET)</title>
                    <literallayout class="monospaced">
<![CDATA[<accessList xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
   <networkItem
          id="1000"
          address="206.160.165.40"
          type="ALLOW" />
   <networkItem
          id="1001"
          address="206.160.165.0/24"
          type="DENY" />
</accessList>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response (GET)</title>
                    <literallayout class="monospaced">
<![CDATA[{
    "networkItems": [
        {
            "address": "206.160.163.21",
            "id": 23,
            "type": "DENY"
        },
        {
            "address": "206.160.165.11",
            "id": 24,
            "type": "DENY"
        },
        {
            "address": "206.160.163.21",
            "id": 25,
            "type": "DENY"
        },
        {
            "address": "206.160.165.11",
            "id": 26,
            "type": "DENY"
        },
        {
            "address": "206.160.123.11",
            "id": 27,
            "type": "DENY"
        },
        {
            "address": "206.160.122.21",
            "id": 28,
            "type": "DENY"
        },
        {
            "address": "206.140.123.11",
            "id": 29,
            "type": "DENY"
        },
        {
            "address": "206.140.122.21",
            "id": 30,
            "type": "DENY"
        }
    ]
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Request (POST)(Required attributes)</title>
                    <literallayout class="monospaced">
<![CDATA[<accessList xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
   <networkItem
      address="206.160.165.1"
      type="ALLOW" />
   <networkItem
      address="206.160.165.2"
      type="DENY" />
</accessList>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Request (POST)(Required attributes)</title>
                    <literallayout class="monospaced">
<![CDATA[{
    "networkItems": [
        {
            "address": "206.160.163.21",
            "id": 23,
            "type": "DENY"
        },
        {
            "address": "206.160.165.11",
            "id": 24,
            "type": "DENY"
        }
    ]
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Request (DELETE)</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response (DELETE)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response (POST)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
            </sect2>
            <sect2>
                <title>Active Health Monitoring</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/healthmonitor</td>
                            <td>Retrieves the health monitor configuration, if one exists</td>
                        </tr>
                        <tr>
                            <td>PUT</td>
                            <td>/loadbalancers/loadBalancerId/healthmonitor</td>
                            <td>Updates the settings for a health monitor</td>
                        </tr>
                        <tr>
                            <td>DELETE</td>
                            <td>/loadbalancers/loadBalancerId/healthmonitor</td>
                            <td>Removes the health monitor</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200, 202
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        The load balancing service includes a health monitoring operation, which periodically checks your backend nodes to ensure they are responding correctly.  In the event that the node is not responding, it will be removed from rotation until the health check determines the node is functional. In addition to being run at periodic intervals, the health check also is run against every node that is added to ensure it is operating properly before allowing it to service traffic.  Only one health monitor is allowed to be enabled on a load balancer at a time. An overview of the supported health monitors are detailed below:
                    </para>
                </sect3>
                <sect3>
                    <title>Connection Monitor</title>
                    <para>
                        The monitor connects to each node on its defined port to ensure that the service is listening properly.  The connect monitor is the most basic type of health check and does no post-processing or protocol specific health checks.   It includes several configurable properties, which are detailed below.
                    </para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para>
                                    <emphasis>delay</emphasis> - The minimum number of seconds to wait before executing the health monitor.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <emphasis>timeout</emphasis> - Maximum number of seconds to wait for a connection to be established before timing out.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <emphasis>attemptsBeforeDeactivation</emphasis> - Number of permissible monitor failures before removing a node from rotation.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </sect3>
                <sect3>
                    <title>HTTP/HTTPS Monitor</title>
                    <para>
                        The HTTP &amp; HTTPS monitor is a more intelligent monitor that is capable of processing a HTTP or HTTPS response to determine the condition of a node.  It supports the same basic properties as the connect monitor and includes three additional attributes that are used to evaluate the HTTP response.
                    </para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><emphasis>delay</emphasis> - The minimum number of seconds to wait before executing the health monitor.</para>
                            </listitem>
                            <listitem>
                                <para><emphasis>timeout</emphasis> - Maximum number of seconds to wait for a connection to be established before timing out.</para>
                            </listitem>
                            <listitem>
                                <para><emphasis>attemptsBeforeDeactivation</emphasis> - Number of permissible monitor failures before removing a node from rotation.</para>
                            </listitem>
                            <listitem>
                                <para><emphasis>path</emphasis> - The HTTP path that will be used in the sample request</para>
                            </listitem>
                            <listitem>
                                <para><emphasis>statusRegex</emphasis> - A regular expression that will be used to evaluate the HTTP status code returned in the response.</para>
                            </listitem>
                            <listitem>
                                <para><emphasis>bodyRegex</emphasis> - A regular expression that will be used to evaluate the contents of the body of the response.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </sect3>
                <sect3>
                    <title>Health Monitor Types</title>
                    <para>
                        All health monitors have a type attribute to signify what kind of monitor it is.
                    </para>
                    <table border="box">
                        <thead>
                            <tr>
                                <td>Name</td>
                                <td>Description</td>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>CONNECT</td>
                                <td>Health monitor is a connect monitor</td>
                            </tr>
                            <tr>
                                <td>HTTP</td>
                                <td>Health monitor is a HTTP monitor</td>
                            </tr>
                            <tr>
                                <td>GET</td>
                                <td>Health monitor is a HTTPS monitor</td>
                            </tr>
                        </tbody>
                    </table>
                </sect3>
                <sect3>
                    <title>Sample XML Response (GET) [Connect Monitor]</title>
                    <literallayout class="monospaced">
<![CDATA[<healthMonitor xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
   type="CONNECT"
   delay="10"
   timeout="10"
   attemptsBeforeDeactivation="3" />]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response (GET) [Connect Monitor]</title>
                    <literallayout class="monospaced">
<![CDATA[{
    "type": "CONNECT",
    "delay": "10",
    "timeout": "10",
    "attemptsBeforeDeactivation": "3"
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Response (GET) [HTTP Monitor]</title>
                    <literallayout class="monospaced">
<![CDATA[<healthMonitor xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
   type="HTTP"
   delay="10"
   timeout="10"
   attemptsBeforeDeactivation="3"
   path="/"
   statusRegex="^[234][0-9][0-9]$"
   bodyRegex="" />]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Response (GET) [HTTPS Monitor]</title>
                    <literallayout class="monospaced">
<![CDATA[<healthMonitor xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
   type="HTTPS"
   delay="10"
   timeout="10"
   attemptsBeforeDeactivation="3"
   path="/"
   statusRegex="^[234][0-9][0-9]$"
   bodyRegex="" />
]]>
                    </literallayout>
                </sect3>
            <note>
                Attributes that are required for a POST request are displayed in the samples, unless otherwise specified.
            </note>
                <sect3>
                    <title>Sample XML Request (PUT) [Connect Monitor]</title>
                    <literallayout class="monospaced">
<![CDATA[<healthMonitor xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
   type="CONNECT"
   delay="10"
   timeout="10"
   attemptsBeforeDeactivation="3" />]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON (PUT) [Connect Monitor]</title>
                    <literallayout class="monospaced">
<![CDATA[{
    "type": "CONNECT",
    "delay": "10",
    "timeout": "10",
    "attemptsBeforeDeactivation": "3"
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Response (POST)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response (PUT)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response (PUT)</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response (DELETE)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
            </sect2>
            <sect2>
                <title>Session Persistence</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/sessionpersistence</td>
                            <td>List session persistence configuration</td>
                        </tr>
                        <tr>
                            <td>POST</td>
                            <td>/loadbalancers/loadBalancerId/sessionpersistence</td>
                            <td>Enable session persistence</td>
                        </tr>
                        <tr>
                            <td>DELETE</td>
                            <td>/loadbalancers/loadBalancerId/sessionpersistence</td>
                            <td>Disable session persistence</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200, 202
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        Session persistence is a feature of the load balancing service which forces subsequent requests from clients to be directed to the same node.  This is common with many web applications that do not inheritly share application state between backend servers.
                    </para>
                </sect3>
                <sect3>
                    <title>Session Persistence Modes</title>
                    <table border="box">
                        <thead>
                            <tr>
                                <td>Name</td>
                                <td>Description</td>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>HTTP_COOKIE</td>
                                <td>A session persistence mechanism that inserts an HTTP cookie and is used to determine the destination backend node. (Supported for HTTP load balancing only.)</td>
                            </tr>
                        </tbody>
                    </table>
                </sect3>
                <sect3>
                    <title>Sample XML Response (GET)</title>
                    <literallayout class="monospaced">
<![CDATA[<sessionPersistence xmlns="http://docs.openstack.org/loadbalancers/api/v1.0" persistenceType="HTTP_COOKIE"/>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response</title>
                    <literallayout class="monospaced">
<![CDATA[{
   "sessionPersistence":{
      "persistenceType":"HTTP_COOKIE"
   }
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Request (POST)</title>
                    <literallayout class="monospaced">
<![CDATA[<sessionPersistence xmlns="http://docs.openstack.org/loadbalancers/api/v1.0" persistenceType="HTTP_COOKIE"/>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Request (POST)</title>
                    <literallayout class="monospaced">
<![CDATA[{
   "sessionPersistence":{
      "persistenceType":"HTTP_COOKIE"
   }
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Response (POST)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
                <sect3>
                    <title>Request (DELETE)</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response (DELETE)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
            </sect2>
            <sect2>
                <title>Connection Logging</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/connectionLogging</td>
                            <td>View current configuration of connection logging</td>
                        </tr>
                        <tr>
                            <td>PUT</td>
                            <td>/loadbalancers/loadBalancerId/connectionLogging</td>
                            <td>Enable or disable connection logging</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200, 202
                </para>
                <para> 
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        This operation allows the user to enable/disable connection logging.
                    </para>
                </sect3>
                <sect3>
                    <title>Request (GET)</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Sample XML Response (GET)</title>
                    <literallayout class="monospaced">
<![CDATA[<connectionLogging xmlns="http://docs.openstack.org/loadbalancers/api/v1.0" enabled="true"/>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response (GET)</title>
                    <literallayout class="monospaced">
<![CDATA[{
   "connectionLogging": {
      "enabled": "true"
   }
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample XML Request (PUT)</title>
                    <literallayout class="monospaced">
<![CDATA[<connectionLogging xmlns="http://docs.openstack.org/loadbalancers/api/v1.0" enabled="true"/>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Request (PUT)</title>
                    <literallayout class="monospaced">
<![CDATA[{
   "connectionLogging":{
      "enabled":"true"
   }
}]]>
                    </literallayout>
                </sect3>
            </sect2>
            <sect2>
                <title>Connection Throttling</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/loadBalancerId/connectionthrottle</td>
                            <td>List connection throttling configuration</td>
                        </tr>
                        <tr>
                            <td>PUT</td>
                            <td>/loadbalancers/loadBalancerId/connectionthrottle</td>
                            <td>Update throttling configuration</td>
                        </tr>
                        <tr>
                            <td>DELETE</td>
                            <td>/loadbalancers/loadBalancerId/connectionthrottle</td>
                            <td>Remove connection throttling configurations</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200, 202
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        The connection throttling feature imposes limits on the number of connections per IP address to help mitigate malicious or abusive traffic to your applications.  The following properties can be configured based on the traffic patterns for your sites.
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para><emphasis>minConnection</emphasis> - Allow at least this number of connections per IP address before applying throttling restrictions.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis>maxConnections</emphasis> - Maximum number of connection to allow for a single IP address.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis>macConnectionRate</emphasis> - Maximum number of connections allowed from a single IP address in the defined rateInterval.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis>rateInterval</emphasis> - Frequency the maxConnectionRate is assessed (in seconds).  For example, A maxConnectionRate of 30 with a rateInterval of 60 would allow a maximum of 30 connections per minute for a single IP address.</para>
                        </listitem>
                    </itemizedlist>
                </sect3>
                <sect3>
                    <title>Request (GET)</title>
                    <para>This operation does not require a request body.</para>
                </sect3>
                <sect3>
                    <title>Sample XML Response (GET)</title>
                    <literallayout class="monospaced">
<![CDATA[<connectionThrottle xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
   minConnections="10"
   maxConnections="100"
   maxConnectionRate="50"
   rateInterval="60" />]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response (GET)</title>
                    <literallayout class="monospaced">
<![CDATA[{
    "maxConnections": 100,
    "minConnections": 10,
    "maxConnectionRate": 50,
    "rateInterval": 60
}]]>
                    </literallayout>
                </sect3>
            <note>
                Attributes that are required are displayed in the samples unless otherwise stated.
            </note>
                <sect3>
                    <title>Sample XML Request (PUT)</title>
                    <literallayout class="monospaced">
<![CDATA[<connectionThrottle xmlns="http://docs.openstack.org/loadbalancers/api/v1.0"
    minConnections="10"
    maxConnections="100"
    maxConnectionRate="50"
    rateInterval="60" />]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON (PUT)</title>
                    <literallayout class="monospaced">
<![CDATA[{
    "maxConnections": 10,
    "minConnections": 100,
    "maxConnectionRate": 50,
    "rateInterval": 60
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Response (PUT)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
                <sect3>
                    <title>Request (DELETE)</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Response (DELETE)</title>
                    <para>
                        This operation does not return a response body.
                    </para>
                </sect3>
            </sect2>
            <sect2>
                <title>Load Balancing Protocols</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/protocols</td>
                            <td>List all supported load balancing protocols</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200
                </para>
                <para>
                    <emphasis>Error Response Code(S):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        All load balancers must define the protocol of the service which is being load balanced.   The protocol selection should be based on the protocol of the backend nodes. When configuring a load balancer, the port selected will be the default port for the given protocol unless otherwise specified.
                    </para>
                </sect3>
                <sect3>
                    <title>Request</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Sample XML Response</title>
                    <literallayout class="monospaced">
<![CDATA[<protocols xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <protocol name="FTP" port="21" />
    <protocol name="HTTP" port="80" />
    <protocol name="IMAPv4" port="143" />
    <protocol name="POP3" port="110" />
    <protocol name="LDAP" port="389" />
    <protocol name="LDAPS" port="636" />
    <protocol name="HTTPS" port="443" />
    <protocol name="IMAPS" port="993" />
    <protocol name="POP3S" port="995" />
    <protocol name="SMTP" port="25" />
</protocols>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response</title>
                    <literallayout>
<![CDATA[{"protocols": [
        {
            "name": "HTTP",
            "port": "80"
        },
        {
            "name": "FTP",
            "port": "21"
        },
        {
            "name": "IMAPv4",
            "port": "143"
        },
        {
            "name": "POP3",
            "port": "110"
        },
        {
            "name": "SMTP",
            "port": "25"
        },
        {
            "name": "LDAP",
            "port": "389"
        },
        {
            "name": "HTTPS",
            "port": "443"
        },
        {
            "name": "IMAPS",
            "port": "993"
        },
        {
            "name": "POP3S",
            "port": "995"
        },
        {
            "name": "LDAPS",
            "port": "636"
        }
    ]
}]]>
                    </literallayout>
                </sect3>
            </sect2>
            <sect2>
                <title>Load Balancing Algorithms</title>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Verb</td>
                            <td>URI</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>GET</td>
                            <td>/loadbalancers/algorithms</td>
                            <td>List all supported load balancing algorithms</td>
                        </tr>
                    </tbody>
                </table>
                <para>
                    <emphasis>Normal Response Code(s):</emphasis> 200
                </para>
                <para>
                    <emphasis>Error Response Code(s):</emphasis> loadBalancerFault(400, 500), serviceUnavailable (503), unauthorized (401), badRequest (400), overLimit (413)
                </para>
                <sect3>
                    <title>Description</title>
                    <para>
                        All load balancers utilize a "load balancer algorithm" that defines how traffic should be directed between backend nodes.  The default algorithm for newly created load balancers is Random, which can be overrided at creation time or changed after the load balancer has been initially provisioned.  The algorithm name is to be constant within a major revision of the load balancing API, though new algorithms may be created with a unique algorithm name within a given major revision of the service API.
                    </para>
                </sect3>
                <sect3>
                    <title>Request</title>
                    <para>
                        This operation does not require a request body.
                    </para>
                </sect3>
                <sect3>
                    <title>Sample XML Response</title>
                    <literallayout class="monospaced">
<![CDATA[<algorithms xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
   <algorithm name="LEAST_CONNECTIONS" />
   <algorithm name="RANDOM" />
   <algorithm name="ROUND_ROBIN" />
   <algorithm name="WEIGHTED_LEAST_CONNECTIONS" />
   <algorithm name="WEIGHTED_ROUND_ROBIN" />
</algorithms>]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Sample JSON Response</title>
                    <literallayout>
<![CDATA[{"algorithms": [
        {
            "name": "LEAST_CONNECTIONS"
        },
        {
            "name": "RANDOM"
        },
        {
            "name": "ROUND_ROBIN"
        },
        {
            "name": "WEIGHTED_LEAST_CONNECTIONS"
        },
        {
            "name": "WEIGHTED_ROUND_ROBIN"
        }
    ]
}]]>
                    </literallayout>
                </sect3>
                <sect3>
                    <title>Load Balancing Algorithms Overview</title>
                    <table border="box">
                        <thead>
                            <tr>
                                <td>Name</td>
                                <td>Description</td>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>LEAST_CONNECTIONS</td>
                                <td>The node with the fewest number of connections will receive requests</td>
                            </tr>
                            <tr>
                                <td>RANDOM</td>
                                <td>Backend servers are selected at random</td>
                            </tr>
                            <tr>
                                <td>ROUND_ROBIN</td>
                                <td>Connections are routed to each of the backend servers in turn</td>
                            </tr>
                            <tr>
                                <td>WEIGHTED_LEAST_CONNECTIONS</td>
                                <td>Each request will be assigned to a node based on the number of concurrent connections to the node and its weight</td>
                            </tr>
                            <tr>
                                <td>WEIGHTED_ROUND_ROBIN</td>
                                <td>A round robin algorithm, but with different proportions of traffic being directed to the backend nodes.  Weights must be defined as part of the load balancer's node configuration.</td>
                            </tr>
                        </tbody>
                    </table>
                </sect3>
            </sect2>
            <sect2>
                <title>Load Balancer Status</title>
                <para>
                    All load balancers have a status attribute to signify the current configuration status of the device. This status is immutable by the caller and is updated automatically based on state changes within the service.  When a load balancer is first created, it will be placed into a build status where the configuration is being generated and applied based on the request.  Once the configuration is applied and finalized, it will be in an ACTIVE status.  In the event of a configuration change or update, the status of the load balancer will change to PENDING_UPDATE to signify configuration changes are being made, but have not yet been finalized.  Load balancers in a suspended status are configured to reject traffic and will not forward requests to backend nodes.
                </para>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Name</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>ACTIVE</td>
                            <td>Load balancer is configured properly and ready to serve traffic to incoming requests via the configured virtual IPs.</td>
                        </tr>
                        <tr>
                            <td>BUILD</td>
                            <td>Load balancer is being provisioned for the first time and configuration is being applied to bring the service online.  The service will not yet be ready to serve incoming requests.</td>
                        </tr>
                        <tr>
                            <td>PENDING_UPDATE</td>
                            <td>Load balancer is online, but configuration changes are being applied to update the service based on a previous request.</td>
                        </tr>
                        <tr>
                            <td>PENDING_DELETE</td>
                            <td>Load balancer is online, but configuration changes are being applied to begin deletion of the service based on a previous request.</td>
                        </tr>
                        <tr>
                            <td>SUSPENDED</td>
                            <td>Load balancer has been taken offline and disabled, contact support.</td>
                        </tr>
                        <tr>
                            <td>ERROR</td>
                            <td>The system encountered an error when attempting to configure the laod balancer, contact support</td>
                        </tr>
                    </tbody>
                </table>
            </sect2>
            <sect2>
                <title>Node Condition</title>
                <para>
                    Every node in the load balancer has an associated condition, which determines its role within the load balancer.
                </para>
                <table border="box">
                    <thead>
                        <tr>
                            <td>Name</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>ENABLED</td>
                            <td>Node is permitted to accept new connections</td>
                        </tr>
                        <tr>
                            <td>DISABLED</td>
                            <td>Node is not permitted to accept any new connections regardless of session persistence configuration.  Existing connections are forcibly terminated</td>
                        </tr>
                        <tr>
                            <td>DRAINING</td>
                            <td>Node is allowed to service existing established connections and connections that are being directed to it as a result of the session persistence configuration</td>
                        </tr>
                    </tbody>
                </table>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="api-faults">
        <title>API Faults</title>
        <para>
            API calls that return an error will return one of the following fault objects.  All fault objects will extend from the base fault, <emphasis>serviceFault</emphasis>, for easier exception handling for languages that support it.
        </para>
        <sect3 id="service-fault">
            <title>serviceFault</title>
            <para>
                The serviceFault and by extension all other faults shall contain a message and detail element containing strings describing the nature of the fault as well as a "code" attribute representing the HTTP response code for convenience. The "code" attribute of the fault is for the convenience of the caller so that they may retrieve the response code from the HTTP response headers or directly from the fault object if they choose. The caller should not expect the serviceFault to be returned directly but should instead expect only one of the child faults to be returned.
            </para>
        </sect3>
        <sect3 id="load-balancer-fault">
            <title>loadBalancerFault</title>
            <para>
                The LoadBalancer fault shall be returned in the event that an error occurred during a loadbalancer operation.
            </para>
            <literallayout class="monospaced">
<![CDATA[<loadBalancerFault code="401" xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <message>Invalid authentication token. Please renew</message>
</loadBalancerFault>]]>
            </literallayout>
        </sect3>
        <sect3 id="bad-request">
            <title>badRequest</title>
            <para>
                The operation was not a valid request. This fault indicates that the data in the request object is invalid, for example a string was used on a parameter that was expecting an integer. The fault will wrap validation errors.
            </para>
            <literallayout class="monospaced">
<![CDATA[<badRequest xmlns="http://docs.openstack.org/loadbalancers/api/v1.0" code="400">
    <message>Validation fault</message>
    <details>The object is not valid</details>
        <validationErrors>
            <message>Node ip is invalid. Please specify a valid ip.</message>
        </validationErrors>
</badRequest>]]>
            </literallayout>
        </sect3>
        <sect3 id="item-not-found">
            <title>itemNotFound</title>
            <para>
            </para>
            <literallayout class="monospaced">
<![CDATA[<itemNotFound code="404" xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <message>Object not Found</message>
</itemNotFound>]]>
            </literallayout>
        </sect3>
        <sect3 id="over-limit">
            <title>overLimit</title>
            <para>
                This fault is returned when the user had exceeded their currently allocated limit.
            </para>
            <literallayout class="monospaced">
<![CDATA[<overLimit code="500" xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <message>Your account is currently over the limit so your request could not be processed.</message>
</overLimit>]]>
            </literallayout>
        </sect3>
        <sect3 id="unauthorized">
            <title>unauthorized</title>
            <para>
                This fault is returned when you attempt to perform an operation you are not authorized to perform.
            </para>
            <literallayout class="monospaced">
<![CDATA[<unauthorized code="404" xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <message>You are not authorized to execute this operation.</message>
</unauthorized>]]>
            </literallayout>
        </sect3>
        <sect3 id="out-of-virtual-ips">
            <title>outOfVirtualIps</title>
            <para>
                This fault indicates that there are no virtual IPs left to assign to a new loadbalancer. In practice, you should not see this fault as virtual IPs will be ordered as capacity is required, but if you do see this simply alert support so that we may make more IPs available.
            </para>
            <literallayout class="monospaced">
<![CDATA[<outOfVirtualIps code="500" xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <message>
        Out of virtual IPs. Please contact support so they can allocate more virtual IPs.
    </message>
</outOfVirtualips>]]>
            </literallayout>
        </sect3>
        <sect3 id="immutable-entity">
            <title>immutableEntity</title>
            <para>
                This fault is returned when a user attempts to modify an item that is not currently in a state that allows modification. For example, load balancers in a status of PENDING_UPDATE, BUILD, or DELETED may not be modified.
            </para>
            <literallayout class="monospaced">
<![CDATA[<immutableEntity code="422" xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <message>The object at the specified URI is immutable and can not be overwritten.</message>
</immutableEntity>]]>
            </literallayout>
        </sect3>
        <sect3 id="unprocessable-entity">
            <title>unprocessableEntity</title>
            <para>
                This fault is returned when an operation is requested on an item that does not support the operation, but the request is properly formed.
            </para>
            <literallayout class="monospaced">
<![CDATA[<unprocessableEntity code="422" xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <message>The Object at the specified URI is unprocessable.</message>
</unprocessableEntity>]]>
            </literallayout>
        </sect3>
        <sect3 id="service-unavailable">
            <title>serviceUnavailable</title>
            <para>
                This fault is returned when the service is unavailable. For example, if the service is undergoing maintenance or otherwise unavailable. Note that this does not necessarily mean the currently configured loadbalancers are unable to process traffic, It simply means that the API is currently unable service requests.
            </para>
            <literallayout class="monospaced">
<![CDATA[<serviceUnavailable code="500" xmlns="http://docs.openstack.org/loadbalancers/api/v1.0">
    <message>The Load balancing service is currently not available</message>
</serviceUnavailable>]]>
            </literallayout>
        </sect3>
    </chapter>
</book>